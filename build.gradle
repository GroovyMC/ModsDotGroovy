import net.neoforged.gradleutils.PomUtilsExtension

plugins {
    id 'groovy'
    id 'java-library'
    id 'maven-publish'
    id 'signing'
    id 'net.neoforged.gradleutils' version '3.0.0-alpha.11' apply false
    id 'io.github.gradle-nexus.publish-plugin' version '2.0.0-rc-1'
    id 'dev.lukebemish.managedversioning' version '1.2.6'
}

managedVersioning {
    versionFile.set rootProject.file('version.properties')

    gitHubActions {
        release {
            prettyName.set 'Release'
            workflowDispatch.set(true)
            gradleJob {
                name.set 'build'
                step {
                    setupGitUser()
                }
                readOnly.set false
                gradlew 'Tag Release', 'tagRelease'
                gradlew 'Build', 'build'
                step {
                    run.set 'git push && git push --tags'
                }
                gradlew 'Publish', 'publish', 'closeAndReleaseSonatypeStagingRepository'
                secret('CENTRAL_MAVEN_USER')
                secret('CENTRAL_MAVEN_PASSWORD')
                secret('GPG_SIGNING_KEY')
                secret('GPG_KEY_PASSWORD')
            }
        }
    }
}

managedVersioning.apply()

println "Building: $version"

nexusPublishing {
    repositories {
        sonatype {
            nexusUrl = uri('https://s01.oss.sonatype.org/service/local/')
            username = System.getenv('CENTRAL_MAVEN_USER') ?: ''
            password = System.getenv('CENTRAL_MAVEN_PASSWORD') ?: ''
        }
    }
}

final String signingKey = System.getenv('GPG_SIGNING_KEY') ?: ''
final String signingPassword = System.getenv('GPG_KEY_PASSWORD') ?: ''
final boolean hasSigningDetails = !signingKey.isEmpty() && !signingPassword.isEmpty()

subprojects {
    project.version = rootProject.version

    apply {
        plugin 'groovy'
        plugin 'java-library'
        plugin 'maven-publish'
        plugin 'signing'
    }

    extensions.create('pomUtils', PomUtilsExtension)

    publishing {
        publications.configureEach {
            pomUtils.githubRepo(pom, 'GroovyMC', 'ModsDotGroovy')

            pomUtils.license(pom, PomUtilsExtension.License.MIT)

            pom {
                developers {
                    developer {
                        id = 'groovymc'
                        name = 'GroovyMC'
                        email = 'holdings@groovymc.org'
                        url = 'https://github.com/GroovyMC/'
                    }
                }
            }
        }
    }

    java {
        withSourcesJar()
        toolchain {
            languageVersion = JavaLanguageVersion.of(17)
        }
    }

    repositories {
        mavenCentral()
    }

    tasks.withType(GroovyCompile).configureEach {
        options.incremental = true
        groovyOptions.optimizationOptions.with {
            indy = true
            groovyDoc = true
            runtimeGroovydoc = true
        }
    }

    tasks.named('groovydoc', Groovydoc).configure {
        use = true
    }

    tasks.register('groovydocJar', Jar).configure {
        archiveClassifier = 'javadoc'
        from groovydoc.destinationDir
        dependsOn 'groovydoc'
    }

    // Publish groovydoc as javadoc
    configurations {
        javadocElements {
            canBeConsumed = true
            canBeResolved = false
            attributes {
                attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage.class, Usage.JAVA_RUNTIME))
                attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category.class, Category.DOCUMENTATION))
                attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling.class, Bundling.EXTERNAL))
                attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType.class, DocsType.JAVADOC))
            }
        }
    }

    project.components.named("java").configure {
        AdhocComponentWithVariants javaComponent = (AdhocComponentWithVariants) it
        javaComponent.addVariantsFromConfiguration(configurations.javadocElements) {}
    }

    artifacts {
        javadocElements groovydocJar
    }

    signing {
        if (hasSigningDetails) useInMemoryPgpKeys(signingKey, signingPassword)
    }

    tasks.withType(Sign).configureEach {
        onlyIf { hasSigningDetails }
    }

    publishing {

    }
}
